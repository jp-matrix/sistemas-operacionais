1- Qual a diferença entre programa e processo?

R- Um programa é um conjunto de instruções armazenado em um arquivo executável, como um .exe ou um script, sendo uma entidade passiva. Um processo é uma instância em execução de um programa. Ele é uma entidade ativa que possui seu próprio espaço de memória, recursos (como arquivos e dispositivos) e um estado de execução.

2- Quais são os estados de um processo e quando ocorrem as transições?

R- Os estados de um processo são:
. Novo (New): O processo está sendo criado.
. Pronto (Ready): O processo está na memória principal, esperando para ser alocado na CPU.
. Executando (Running): As instruções do processo estão sendo executadas pela CPU.
. Esperando (Waiting): O processo está aguardando a conclusão de algum evento (ex: uma operação de I/O).
. Terminado (Terminated): O processo completou sua execução e foi finalizado.

Já os processos são:
. Novo -> Pronto: O sistema operacional finaliza a criação do processo.

. Pronto -> Executando: O escalonador de processos seleciona o processo para a CPU.

. Executando -> Pronto: A fatia de tempo do processo na CPU expira (preempção) ou o sistema operacional decide interrompê-lo.

. Executando -> Esperando: O processo solicita uma operação de I/O ou espera por um evento.

. Esperando -> Pronto: O evento pelo qual o processo esperava (ex: I/O) é concluído.

. Executando -> Terminado: O processo termina sua execução de forma normal ou por um erro.

3- O que contém um Process Control Block (PCB)?

R- . ID do Processo (PID): Identificação única do processo.

. Estado do Processo: O estado atual (ex: Pronto, Executando).

. Contador de Programa: O endereço da próxima instrução a ser executada.

. Registradores da CPU: O conteúdo dos registradores da CPU, salvos quando o processo é interrompido.

. Informações de Agendamento: Prioridade do processo, ponteiros para as filas de agendamento.

. Informações de Gerenciamento de Memória: Ponteiros para as tabelas de páginas ou segmentos.

. Informações de Contabilidade: Tempo de CPU usado, tempo total de execução.

. Informações de I/O: Lista de arquivos abertos e dispositivos alocados para o processo.

4- O que acontece com os recursos de um processo quando ele termina?

R- Quando um processo termina, todos os seus recursos alocados são liberados e retornados ao sistema operacional para uso futuro.

5- Qual a diferença entre fork() e exec() no UNIX?

R- A chamada de sistema fork() cria um novo processo, chamado de processo filho, que é uma cópia quase exata do processo que a chamou, o processo pai. A diferença é que o processo filho recebe um valor de retorno de 0, enquanto o processo pai recebe o PID do processo filho.

A chamada de sistema exec() substitui o código e os dados do processo que a chamou por um novo programa. A identidade do processo (PID) permanece a mesma, mas o conteúdo da memória, incluindo o código e os dados, é totalmente substituído pelo novo programa. Ela é frequentemente usada logo após um fork() para que o processo filho execute um programa diferente do pai.

6- Como funciona a hierarquia de processos em UNIX?

R- O primeiro processo a ser executado, geralmente o init (ou systemd em sistemas mais modernos), é o pai de todos os outros processos. Quando um processo chama fork(), ele se torna o pai do novo processo filho. Cada processo, exceto o init, tem um processo pai. Quando um processo pai termina antes de seu filho, o processo filho se torna "órfão" e é adotado pelo processo init.

7- Compare memória compartilhada e troca de mensagens (IPC).

R- Memória Compartilhada: Um ou mais processos acessam uma região comum de memória. Os processos escrevem e leem dados diretamente nessa área, eliminando a necessidade de chamadas de sistema para cada comunicação. É extramemente rápida e mais complexa de implementar e gerenciar.

Troca de Mensagens: Os processos se comunicam enviando e recebendo mensagens através de canais de comunicação gerenciados pelo sistema operacional. É mais fácil de usar e implementar e mais lenta que a memória compartilhada.

8- Cite exemplos de chamadas de sistema usadas em IPC.

R- Troca de Mensagens:

send() e receive(): Para enviar e receber mensagens, respectivamente.

msgget(): Cria ou acessa uma fila de mensagens.

msgsnd(): Envia uma mensagem para uma fila.

msgrcv(): Recebe uma mensagem de uma fila.


Memória Compartilhada:

shmget(): Cria ou acessa uma região de memória compartilhada.

shmat(): Anexa uma região de memória compartilhada ao espaço de endereço do processo.

shmdt(): Desanexa uma região de memória compartilhada.

9- Por que é importante que o sistema operacional faça gerenciamento de processos?

R- É fundamental porque permite que o sistema operacional maximize a utilização da CPU, alocar e desalocar recursos, a proteger processos e facilitar a comunicação.

10- Explique a diferença entre processos independentes e processos cooperativos.

R- Processos Independentes: São processos que não compartilham dados ou estado com outros processos. Eles não precisam de comunicação ou sincronização para operar.

Processos Cooperativos: São processos que podem afetar ou ser afetados pela execução de outros. Eles compartilham dados e precisam de mecanismos de comunicação e sincronização para coordenar suas atividades.

11- O que é um processo zumbi em UNIX/Linux?

R- Um processo zumbi (ou defunct) é um processo que já completou sua execução, mas seu PCB ainda existe na tabela de processos do sistema. Isso ocorre porque o processo pai ainda não leu o status de saída do processo filho usando a chamada de sistema wait() ou waitpid(). A existência de um processo zumbi não consome recursos de CPU ou memória, mas ele mantém uma entrada na tabela de processos, o que pode ser um problema se muitos zumbis se acumularem.

12- Explique a diferença entre chamadas bloqueantes e não bloqueantes em IPC.

R- Chamadas Bloqueantes: Uma chamada de sistema é considerada bloqueante quando o processo que a invoca é suspenso (bloqueado) até que a operação seja concluída.

Chamadas Não Bloqueantes: Uma chamada de sistema é não bloqueante quando ela retorna imediatamente, independentemente de a operação ter sido concluída ou não. Ela retorna um código de erro ou um valor especial se a operação não puder ser concluída imediatamente.

13- Qual a diferença entre processo pesado (process) e thread (processo leve)?

R- Processo Pesado (Processo): Possui seu próprio espaço de endereço de memória, recursos (arquivos, etc.), e um único fluxo de execução (thread). A criação e a troca de contexto entre processos são mais lentas devido à necessidade de salvar e carregar todo o estado do processo (PCB e registradores).

Processo Leve (Thread): É um fluxo de execução dentro de um processo. As threads de um mesmo processo compartilham o mesmo espaço de endereço, código e recursos. Apenas o contador de programa, registradores e a pilha são únicos para cada thread. A criação e a troca de contexto entre threads são muito mais rápidas, pois não é necessário comutar espaços de endereço.

14- Por que sistemas operacionais multiprogramados precisam de troca de contexto (context switch)?

R-  É essencial em sistemas multiprogramados para permitir que o sistema operacional mude a execução de um processo para outro. Sendo necessário para permitir a multitarefa e aumentar a utilização da CPU.

15- Cite vantagens e desvantagens da comunicação via memória compartilhada.

R- Vantangens: É o método de IPC mais rápido, pois a comunicação ocorre na velocidade da memória; Garantir eficiência sendo ideal para transferir grandes volumes de dados de forma eficiente, pois evita a sobrecarga de copiar dados entre o espaço do usuário e o espaço do kernel.

Desvantagens: Requer mecanismos de sincronização explícitos para garantir que múltiplos processos não acessem a mesma região de memória simultaneamente; É mais complexa de ser implementada do que a troca de mensagens;  A falta de isolamento entre os processos na área de memória compartilhada pode ser um risco de segurança se não for gerenciada corretamente.